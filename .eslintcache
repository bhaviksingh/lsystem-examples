[{"/Users/bvk/Documents/Active/tend/lsystem-examples/src/index.tsx":"1","/Users/bvk/Documents/Active/tend/lsystem-examples/src/P5Draw.tsx":"2","/Users/bvk/Documents/Active/tend/lsystem-examples/src/staticExamples.tsx":"3","/Users/bvk/Documents/Active/tend/lsystem-examples/src/InteractiveCreator.tsx":"4","/Users/bvk/Documents/Active/tend/lsystem-examples/src/lib/easyCam.js":"5","/Users/bvk/Documents/Active/tend/lsystem-examples/src/LSCustomizer.tsx":"6"},{"size":714,"mtime":1610750923768,"results":"7","hashOfConfig":"8"},{"size":3184,"mtime":1610756652824,"results":"9","hashOfConfig":"8"},{"size":2711,"mtime":1608200512362,"results":"10","hashOfConfig":"8"},{"size":1217,"mtime":1610755914010,"results":"11","hashOfConfig":"8"},{"size":41977,"mtime":1608198904219,"results":"12","hashOfConfig":"8"},{"size":8819,"mtime":1610755256329,"results":"13","hashOfConfig":"8"},{"filePath":"14","messages":"15","errorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"16","usedDeprecatedRules":"17"},"7co05w",{"filePath":"18","messages":"19","errorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"20","messages":"21","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"22","messages":"23","errorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"24","usedDeprecatedRules":"17"},{"filePath":"25","messages":"26","errorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":14,"source":"27","usedDeprecatedRules":"28"},{"filePath":"29","messages":"30","errorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"31","usedDeprecatedRules":"17"},"/Users/bvk/Documents/Active/tend/lsystem-examples/src/index.tsx",["32","33","34"],"import React from 'react';\nimport ReactDOM from 'react-dom';\nimport P5Draw from './P5Draw';\nimport \"./global.css\";\nimport staticExamples from './staticExamples';\nimport InteractiveCreator from './InteractiveCreator';\nimport LSCustomizer from './LSCustomizer';\n\n\nReactDOM.render(\n  <React.StrictMode>\n    <InteractiveCreator />\n    {/* {staticExamples()} */}\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n//reportWebVitals();\n\n//Useful tings\n//<P5Draw commandString=\"FFF+F\" length={10} />",["35","36"],"/Users/bvk/Documents/Active/tend/lsystem-examples/src/P5Draw.tsx",["37","38","39","40","41"],"/Users/bvk/Documents/Active/tend/lsystem-examples/src/staticExamples.tsx",[],"/Users/bvk/Documents/Active/tend/lsystem-examples/src/InteractiveCreator.tsx",["42","43","44","45"],"import React from \"react\"\nimport lsystem, { Axiom, parseAxiom, Production } from \"@bvk/lsystem\"\nimport { axiomToStr } from \"@bvk/lsystem/dist/parser\";\nimport LSystem from \"@bvk/lsystem\";\nimport P5Draw from \"./P5Draw\";\nimport LSCustomizer from \"./LSCustomizer\";\n\n\ninterface InteractiveCreatorState {\n  currentlyDrawing: Axiom | undefined\n}\nexport default class InteractiveCreator extends React.Component<{}, InteractiveCreatorState> {\n  state = {\n    currentlyDrawing: undefined\n  }\n  LSIterated = (LS: LSystem) => {\n    console.log(\"LS Iterated\");\n    console.log(LS.getIterationAsObject());\n    this.setState({ currentlyDrawing: LS.getIterationAsObject() })\n  }\n  LSReset = (LS: LSystem) => {\n    console.log(\"LS Reset\");\n    console.log(LS.productions);\n    console.log(LS.getIterationAsObject());\n    this.setState({ currentlyDrawing: LS.getIterationAsObject() })\n  }\n\n  render() {\n    return (\n      <div>\n        <LSCustomizer\n          onLSIterated={this.LSIterated}\n          onLSReset={this.LSReset} />\n        <P5Draw commandString={this.state.currentlyDrawing} key={this.state.currentlyDrawing != undefined ? axiomToStr(this.state.currentlyDrawing as unknown as Axiom) : \"blank\"} />\n      </div>\n    )\n  }\n}","/Users/bvk/Documents/Active/tend/lsystem-examples/src/lib/easyCam.js",["46","47","48","49","50","51","52","53","54","55","56","57","58","59","60","61","62","63","64","65"],"/*\n * \n * The p5.EasyCam library - Easy 3D CameraControl for p5.js and WEBGL.\n *\n *   Copyright Â© 2017-2020 by p5.EasyCam authors\n *\n *   Source: https://github.com/freshfork/p5.EasyCam\n *\n *   MIT License: https://opensource.org/licenses/MIT\n * \n * \n * explanatory notes:\n * \n * p5.EasyCam is a derivative of the original PeasyCam Library by Jonathan Feinberg \n * and combines new useful features with the great look and feel of its parent.\n * \n */\n\n \n \n'use strict';\nimport p5 from \"p5\"\n\n\n/** @namespace  */\nexport var Dw = (function(ext) {\n  \n/**\n * EasyCam Library Info\n */\nconst INFO = \n{\n  /** name    */ LIBRARY : \"p5.EasyCam\",\n  /** version */ VERSION : \"1.0.10\",\n  /** author  */ AUTHOR  : \"p5.EasyCam authors\",\n  /** source  */ SOURCE  : \"https://github.com/freshfork/p5.EasyCam\",\n  \n  toString : function(){\n    return this.LIBRARY+\" v\"+this.VERSION+\" by \"+this.AUTHOR+\" (\"+this.SOURCE+\")\";\n  },\n  \n};\n\n\n/**\n * EasyCam\n *\n * <pre>\n *\n *   new Dw.EasyCam(p5.RendererGL, {\n *     distance : z,                 // scalar\n *     center   : [x, y, z],         // vector\n *     rotation : [q0, q1, q2, q3],  // quaternion\n *     viewport : [x, y, w, h],      // array\n *   }\n *\n * </pre>\n *\n * @param {p5.RendererGL} renderer - p5 WEBGL renderer\n * @param {Object}        args     - {distance, center, rotation, viewport}\n *\n */\nclass EasyCam {\n\n  /**\n   * @constructor\n   */\n  constructor(renderer, args) {\n    \n\n    // WEBGL renderer required\n    if(!(renderer instanceof p5.RendererGL)){\n      console.log(\"renderer needs to be an instance of p5.RendererGL\");\n      return;\n    }\n    \n    // define default args\n    args = args || {};\n    if(args.distance === undefined) args.distance  = 500;\n    if(args.center   === undefined) args.center    = [0, 0, 0];\n    if(args.rotation === undefined) args.rotation  = Rotation.identity();\n    if(args.viewport === undefined) args.viewport  = [0, 0, renderer.width, renderer.height];\n   \n\n    // library info\n    this.INFO = INFO;\n\n    // set renderer, graphics, p5\n    // this.renderer;\n    // this.graphics;\n    // this.P5\n    this.setCanvas(renderer);\n\n    // self reference\n    var cam = this;\n    this.cam = cam;\n    \n    // some constants\n    this.LOOK = [0, 0, 1];\n    this.UP   = [0, 1, 0];\n\n    // principal axes flags\n    this.AXIS = new function() {\n      this.YAW   = 0x01;\n      this.PITCH = 0x02;\n      this.ROLL  = 0x04;\n      this.ALL   = this.YAW | this.PITCH | this.ROLL;\n    };\n  \n    // mouse action constraints\n    this.SHIFT_CONSTRAINT = 0; // applied when pressing the shift key\n    this.FIXED_CONSTRAINT = 0; // applied, when set by user and SHIFT_CONSTRAINT is 0\n    this.DRAG_CONSTRAINT  = 0; // depending on SHIFT_CONSTRAINT and FIXED_CONSTRAINT, default is ALL\n    \n    // mouse action speed\n    this.scale_rotation  = 0.001;\n    this.scale_pan       = 0.0002;\n    this.scale_zoom      = 0.001;\n    this.scale_zoomwheel = 20.0;\n    \n    // zoom limits\n    this.distance_min_limit = 0.01;\n    this.distance_min       = 1.0;\n    this.distance_max       = Number.MAX_VALUE;\n    \n    // main state\n    this.state = {\n      distance : args.distance,         // scalar\n      center   : args.center.slice(),   // vec3\n      rotation : args.rotation.slice(), // quaternion\n      \n      copy : function(dst){\n        dst = dst || {};\n        dst.distance = this.distance;      \n        dst.center   = this.center.slice(); \n        dst.rotation = this.rotation.slice();\n        return dst;\n      },\n    };\n\n    // backup-state at start\n    this.state_reset  = this.state.copy();\n    // backup-state, probably not required\n    this.state_pushed = this.state.copy();\n    \n    // viewport for the mouse-pointer [x,y,w,h]\n    this.viewport = args.viewport.slice();\n    \n\n    \n    \n    \n    // mouse/touch/key action handler\n    this.mouse = {\n      \n      cam : cam,\n      \n      curr   : [0,0,0],\n      prev   : [0,0,0],\n      dist   : [0,0,0],\n      mwheel : 0,\n      \n      isPressed   : false, // true if (istouchdown || ismousedown)\n      istouchdown : false, // true, if input came from a touch\n      ismousedown : false, // true, if input came from a mouse\n      \n      BUTTON : {  LMB:0x01, MMB:0x02, RMB:0x04  },\n      \n      button : 0,\n     \n      mouseDragLeft   : cam.mouseDragRotate.bind(cam),\n      mouseDragCenter : cam.mouseDragPan   .bind(cam),\n      mouseDragRight  : cam.mouseDragZoom  .bind(cam),\n      mouseWheelAction: cam.mouseWheelZoom .bind(cam),\n      \n      touchmoveSingle : cam.mouseDragRotate.bind(cam),\n      touchmoveMulti  : function(){\n                          cam.mouseDragPan();\n                          cam.mouseDragZoom();\n                        },\n     \n      \n      insideViewport : function(x, y){\n        var x0 = cam.viewport[0], x1 = x0 + cam.viewport[2];\n        var y0 = cam.viewport[1], y1 = y0 + cam.viewport[3];\n        return (x > x0) && (x < x1) && (y > y0) && (y < y1);\n      },\n      \n      solveConstraint : function(){\n        var dx = this.dist[0];\n        var dy = this.dist[1];\n        \n        // YAW, PITCH\n        if (this.shiftKey && !cam.SHIFT_CONSTRAINT && Math.abs(dx - dy) > 1) {\n          cam.SHIFT_CONSTRAINT = Math.abs(dx) > Math.abs(dy) ? cam.AXIS.YAW : cam.AXIS.PITCH;\n        }\n        \n        // define constraint by increasing priority\n        cam.DRAG_CONSTRAINT = cam.AXIS.ALL;\n        if(cam.FIXED_CONSTRAINT) cam.DRAG_CONSTRAINT = cam.FIXED_CONSTRAINT;\n        if(cam.SHIFT_CONSTRAINT) cam.DRAG_CONSTRAINT = cam.SHIFT_CONSTRAINT;\n      },\n\n      updateInput : function(x,y,z){\n        var mouse = cam.mouse;\n        var pd = cam.P5.pixelDensity();\n        \n        mouse.prev[0] = mouse.curr[0];\n        mouse.prev[1] = mouse.curr[1];\n        mouse.prev[2] = mouse.curr[2];\n        \n        mouse.curr[0] = x;\n        mouse.curr[1] = y;\n        mouse.curr[2] = z;\n        \n        mouse.dist[0] = -(mouse.curr[0] - mouse.prev[0]) / pd;\n        mouse.dist[1] = -(mouse.curr[1] - mouse.prev[1]) / pd;\n        mouse.dist[2] = -(mouse.curr[2] - mouse.prev[2]) / pd;\n      },\n\n      \n      \n      //////////////////////////////////////////////////////////////////////////\n      // mouseinput\n      //////////////////////////////////////////////////////////////////////////\n\n      mousedown : function(event){\n        var mouse = cam.mouse;\n        \n        if(event.button === 0) mouse.button |= mouse.BUTTON.LMB;\n        if(event.button === 1) mouse.button |= mouse.BUTTON.MMB;\n        if(event.button === 2) mouse.button |= mouse.BUTTON.RMB;\n        \n        if(mouse.insideViewport(event.x, event.y)){\n          mouse.updateInput(event.x, event.y, event.y);\n          mouse.ismousedown = mouse.button > 0;\n          mouse.isPressed   = mouse.ismousedown;\n          cam.SHIFT_CONSTRAINT = 0;\n        } \n      },\n      \n      mousedrag : function(){\n        var pd = cam.P5.pixelDensity();\n        \n        var mouse = cam.mouse;\n        if(mouse.ismousedown){\n          \n          var x = cam.P5.mouseX;\n          var y = cam.P5.mouseY;\n          var z = y;\n          \n          mouse.updateInput(x, y, z);\n          mouse.solveConstraint();\n          \n          var LMB = mouse.button & mouse.BUTTON.LMB;\n          var MMB = mouse.button & mouse.BUTTON.MMB;\n          var RMB = mouse.button & mouse.BUTTON.RMB;\n          \n          if(LMB && mouse.mouseDragLeft  ) mouse.mouseDragLeft();\n          if(MMB && mouse.mouseDragCenter) mouse.mouseDragCenter();\n          if(RMB && mouse.mouseDragRight ) mouse.mouseDragRight();\n        }\n      },\n      \n      mouseup : function(event){\n        var mouse = cam.mouse;\n        \n        if(event.button === 0) mouse.button &= ~mouse.BUTTON.LMB;\n        if(event.button === 1) mouse.button &= ~mouse.BUTTON.MMB;\n        if(event.button === 2) mouse.button &= ~mouse.BUTTON.RMB;\n        \n        mouse.ismousedown = mouse.button > 0;\n        mouse.isPressed = (mouse.istouchdown || mouse.ismousedown);\n        cam.SHIFT_CONSTRAINT = 0;\n      },\n      \n      dblclick : function(event){\n        var x = event.x;\n        var y = event.y;\n        if(cam.mouse.insideViewport(x, y)){\n          cam.reset();\n        }\n      },\n      \n      wheel : function(event){\n        var x = event.x;\n        var y = event.y;\n        var mouse = cam.mouse;\n        if(mouse.insideViewport(x, y)){\n          mouse.mwheel = event.deltaY * 0.01;\n          if(mouse.mouseWheelAction) mouse.mouseWheelAction();\n        }\n      },\n      \n      \n      \n      //////////////////////////////////////////////////////////////////////////\n      // touchinput\n      //////////////////////////////////////////////////////////////////////////\n      \n      evaluateTouches : function(event){\n        var touches = event.touches;\n        var avg_x = 0.0;\n        var avg_y = 0.0;\n        var avg_d = 0.0;\n        var i, dx, dy, count = touches.length;\n\n        // center, averaged touch position\n        for(i = 0; i < count; i++){\n          avg_x += touches[i].clientX;\n          avg_y += touches[i].clientY;\n        }\n        avg_x /= count;\n        avg_y /= count;\n        \n        // offset, mean distance to center\n        for(i = 0; i < count; i++){\n          dx = avg_x - touches[i].clientX;\n          dy = avg_y - touches[i].clientY;\n          avg_d += Math.sqrt(dx*dx + dy*dy);\n        }\n        avg_d /= count;\n        \n        cam.mouse.updateInput(avg_x, avg_y, -avg_d);\n      },\n      \n\n      touchstart : function(event){\n        event.preventDefault();\n\t\t    event.stopPropagation();\n        \n        var mouse = cam.mouse;\n        \n        mouse.evaluateTouches(event);\n        mouse.istouchdown = mouse.insideViewport(mouse.curr[0], mouse.curr[1]);\n        mouse.isPressed = (cam.mouse.istouchdown || cam.mouse.ismousedown);\n    \n        mouse.dbltap(event);\n      },\n      \n      touchmove : function(event){\n        event.preventDefault();\n\t\t    event.stopPropagation();\n        \n        var mouse = cam.mouse;\n        \n        if(mouse.istouchdown){\n          \n          mouse.evaluateTouches(event);  \n          mouse.solveConstraint();\n\n          if(event.touches.length === 1){\n            mouse.touchmoveSingle();\n          } else {\n            mouse.touchmoveMulti();\n            mouse.tapcount = 0;\n          }\n        }\n      },\n      \n      touchend : function(event){\n        event.preventDefault();\n\t\t    event.stopPropagation();\n        \n        var mouse = cam.mouse;\n        mouse.istouchdown = false;\n        mouse.isPressed = (mouse.istouchdown || mouse.ismousedown);\n        cam.SHIFT_CONSTRAINT = 0;\n        \n        if(mouse.tapcount >= 2){\n          if(mouse.insideViewport(mouse.curr[0], mouse.curr[1])){\n            cam.reset();\n          }\n          mouse.tapcount = 0;\n        }\n      },\n\n      \n      tapcount : 0,\n       \n      dbltap : function(event) {\n        if(cam.mouse.tapcount++ == 0) {\n          setTimeout( function() { \n            cam.mouse.tapcount = 0; \n          }, 350 );\n        } \n      },\n      \n      \n      \n      //////////////////////////////////////////////////////////////////////////\n      // keyingput\n      //////////////////////////////////////////////////////////////////////////\n      \n      // key-event for shift constraints\n      shiftKey : false,\n   \n      keydown : function(event){\n        var mouse = cam.mouse;\n        if(!mouse.shiftKey){\n          mouse.shiftKey   = (event.keyCode === 16);\n        }\n      },\n      \n      keyup : function(event){\n        var mouse = cam.mouse;\n        if(mouse.shiftKey){\n          mouse.shiftKey = (event.keyCode !== 16);\n          if(!mouse.shiftKey){\n            cam.SHIFT_CONSTRAINT = 0;\n          }\n        }\n      }\n      \n    };\n    \n    \n    \n    // camera mouse listeners\n    this.attachMouseListeners();\n   \n    // P5 registered callbacks, TODO unregister on dispose\n    this.auto_update = true;\n    this.P5.registerMethod('pre', function(){\n      if(cam.auto_update){\n        cam.update(); \n      }\n    });\n \n    // damped camera transition\n    this.dampedZoom = new DampedAction(function(d){ cam.zoom   (d * cam.getZoomMult    ()); }  );\n    this.dampedPanX = new DampedAction(function(d){ cam.panX   (d * cam.getPanMult     ()); }  );\n    this.dampedPanY = new DampedAction(function(d){ cam.panY   (d * cam.getPanMult     ()); }  );\n    this.dampedRotX = new DampedAction(function(d){ cam.rotateX(d * cam.getRotationMult()); }  );\n    this.dampedRotY = new DampedAction(function(d){ cam.rotateY(d * cam.getRotationMult()); }  );\n    this.dampedRotZ = new DampedAction(function(d){ cam.rotateZ(d * cam.getRotationMult()); }  );\n    \n    // interpolated camera transition\n    this.timedRot  = new Interpolation(cam.setInterpolatedRotation.bind(cam));\n    this.timedPan  = new Interpolation(cam.setInterpolatedCenter  .bind(cam));\n    this.timedzoom = new Interpolation(cam.setInterpolatedDistance.bind(cam));\n  }\n  \n  \n\n  /**\n   * sets the WEBGL renderer the camera is working on\n   *\n   * @param {p5.RendererGL} renderer ... p5 WEBGL renderer\n   */\n  setCanvas(renderer){\n    if(renderer instanceof p5.RendererGL){\n      // p5js seems to be not very clear about this\n      // ... a bit confusing, so i guess this could change in future releases\n      this.renderer = renderer;\n      if(renderer._pInst instanceof p5){\n        this.graphics = renderer;\n      } else {\n        this.graphics = renderer._pInst;\n      }\n      this.P5 = this.graphics._pInst;\n    } else {\n      this.graphics = undefined;\n      this.renderer = undefined;\n    }\n  }\n\n  /** @return {p5.RendererGL} the currently used renderer */\n  getCanvas(){\n    return this.renderer;\n  }\n  \n  \n  attachListener(el, ev, fx, op){\n    if(!el || (el === fx.el)){\n      return;\n    }\n    \n    this.detachListener(fx);\n\n    fx.el = el;\n    fx.ev = ev;\n    fx.op = op;\n    fx.el.addEventListener(fx.ev, fx, fx.op);\n  }\n  \n  detachListener(fx){\n    if(fx.el) {\n      fx.el.removeEventListener(fx.ev, fx, fx.op);\n      fx.el = undefined;\n    }\n  }\n  \n  /** attaches input-listeners (mouse, touch, key) to the used renderer */\n  attachMouseListeners(renderer){\n    var cam = this.cam;\n    var mouse = cam.mouse;\n    \n    renderer = renderer || cam.renderer;\n    if(renderer){\n      \n      var op = { passive:false };\n      var el = renderer.elt;\n      \n      cam.attachListener(el    , 'mousedown' , mouse.mousedown , op);\n      cam.attachListener(el    , 'mouseup'   , mouse.mouseup   , op);\n      cam.attachListener(el    , 'dblclick'  , mouse.dblclick  , op);\n      cam.attachListener(el    , 'wheel'     , mouse.wheel     , op);\n      cam.attachListener(el    , 'touchstart', mouse.touchstart, op);\n      cam.attachListener(el    , 'touchend'  , mouse.touchend  , op);\n      cam.attachListener(el    , 'touchmove' , mouse.touchmove , op);\n      cam.attachListener(window, 'keydown'   , mouse.keydown   , op);\n      cam.attachListener(window, 'keyup'     , mouse.keyup     , op);\n    }\n  }\n  \n  /** detaches all attached input-listeners */\n  removeMouseListeners(){\n    var cam = this.cam;\n    var mouse = cam.mouse;\n       \n    cam.detachListener(mouse.mousedown );\n    cam.detachListener(mouse.mouseup   );\n    cam.detachListener(mouse.dblclick  );\n    cam.detachListener(mouse.wheel     );\n    cam.detachListener(mouse.keydown   );\n    cam.detachListener(mouse.keyup     );\n    cam.detachListener(mouse.touchstart);\n    cam.detachListener(mouse.touchend  );\n    cam.detachListener(mouse.touchmove );\n  }\n  \n  /** Disposes/releases the camera. */\n  dispose(){\n    // TODO: p5 unregister 'pre', ... not available in 0.5.16\n    this.removeMouseListeners();\n  }\n  \n  /** @return {boolean} the current autoUpdate state */\n  getAutoUpdate(){\n    return this.auto_update;\n  }\n  /** \n   * If true, the EasyCam will update automatically in a pre-draw step.\n   * This updates the camera state and updates the renderers \n   * modelview/camera matrix.\n   *\n   * If false, the update() needs to be called manually.\n   *\n   * @param {boolean} the new autoUpdate state \n   */\n  setAutoUpdate(status){\n    this.auto_update = status;\n  }\n  \n\n  /** \n   * Updates the camera state (interpolated / damped animations) and updates\n   * the renderers' modelview/camera matrix.\n   *\n   * if \"auto_update\" is true, this is called automatically in a pre-draw call.\n   */\n  update(){\n    var cam = this.cam;\n    var mouse = cam.mouse;\n    \n    mouse.mousedrag();\n\n    var b_update = false;\n    b_update |= cam.dampedZoom.update();\n    b_update |= cam.dampedPanX.update();\n    b_update |= cam.dampedPanY.update();\n    b_update |= cam.dampedRotX.update();\n    b_update |= cam.dampedRotY.update();\n    b_update |= cam.dampedRotZ.update();\n    \n    // interpolated actions have lower priority then damped actions\n    if(b_update){\n      cam.timedRot .stop();\n      cam.timedPan .stop();\n      cam.timedzoom.stop();\n    } else {\n      cam.timedRot .update();\n      cam.timedPan .update();\n      cam.timedzoom.update();\n    }\n \n    cam.apply();\n  }\n  \n  /** \n   * Applies the current camera state to the renderers' modelview/camera matrix.\n   * If no argument is given, then the cameras currently set renderer is used.\n   */\n  apply(renderer) { \n\n    var cam = this.cam;\n    renderer = renderer || cam.renderer;\n    \n    if(renderer){\n      this.camEYE = this.getPosition(this.camEYE);   \n      this.camLAT = this.getCenter  (this.camLAT);\n      this.camRUP = this.getUpVector(this.camRUP);\n      \n      if(undefined===renderer._curCamera)\n        renderer.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2],\n                        this.camLAT[0], this.camLAT[1], this.camLAT[2],\n                        this.camRUP[0], this.camRUP[1], this.camRUP[2]);\n      else\n        renderer._curCamera.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2],\n                        this.camLAT[0], this.camLAT[1], this.camLAT[2],\n                        this.camRUP[0], this.camRUP[1], this.camRUP[2]);\n    }\n\n  }\n  \n\n  /** @param {int[]} the new viewport-def, as [x,y,w,h] */\n  setViewport(viewport){\n    this.viewport = viewport.slice();\n  }\n  \n  /** @returns {int[]} the current viewport-def, as [x,y,w,h] */\n  getViewport(){\n    return this.viewport;\n  }\n  \n  \n\n  //\n  // mouse state changes\n  //\n  \n  /** implemented zoom-cb for mouswheel handler.*/\n  mouseWheelZoom() {\n    var cam = this;\n    var mouse = cam.mouse;\n    cam.dampedZoom.addForce(mouse.mwheel * cam.scale_zoomwheel);\n  }\n  \n  /** implemented zoom-cb for mousedrag/touch handler.*/\n  mouseDragZoom() {\n    var cam = this;\n    var mouse = cam.mouse;\n    cam.dampedZoom.addForce(-mouse.dist[2]);\n  }\n  \n  /** implemented pan-cb for mousedrag/touch handler.*/\n  mouseDragPan() {\n    var cam = this;\n    var mouse = cam.mouse;\n\n    cam.dampedPanX.addForce((cam.DRAG_CONSTRAINT & cam.AXIS.YAW  ) ? mouse.dist[0] : 0);\n    cam.dampedPanY.addForce((cam.DRAG_CONSTRAINT & cam.AXIS.PITCH) ? mouse.dist[1] : 0);\n  }\n  \n  /** implemented rotate-cb for mousedrag/touch handler.*/\n  mouseDragRotate() {\n    var cam = this;\n    var mouse = cam.mouse;\n    \n    var mx = mouse.curr[0], my = mouse.curr[1];\n    var dx = mouse.dist[0], dy = mouse.dist[1];\n\n    // mouse [-1, +1]\n    var mxNdc = Math.min(Math.max((mx - cam.viewport[0]) / cam.viewport[2], 0), 1) * 2 - 1;\n    var myNdc = Math.min(Math.max((my - cam.viewport[1]) / cam.viewport[3], 0), 1) * 2 - 1;\n\n    if (cam.DRAG_CONSTRAINT & cam.AXIS.YAW) {\n      cam.dampedRotY.addForce(+dx * (1.0 - myNdc * myNdc));\n    }\n    if (cam.DRAG_CONSTRAINT & cam.AXIS.PITCH) {\n      cam.dampedRotX.addForce(-dy * (1.0 - mxNdc * mxNdc));\n    }\n    if (cam.DRAG_CONSTRAINT & cam.AXIS.ROLL) {\n      cam.dampedRotZ.addForce(-dx * myNdc);\n      cam.dampedRotZ.addForce(+dy * mxNdc);\n    }\n  }\n  \n  \n  \n  //\n  // damped multipliers\n  //\n  /** (private) returns the used zoom -multiplier for damped actions. */\n  getZoomMult(){\n    return this.state.distance * this.scale_zoom;\n  }\n  /** (private) returns the used pan-multiplier for damped actions. */\n  getPanMult(){\n    return this.state.distance * this.scale_pan;\n  }\n  /** (private) returns the used rotate-multiplier for damped actions. */\n  getRotationMult(){\n    return Math.pow(Math.log10(1 + this.state.distance), 0.5) * this.scale_rotation;\n  }\n  \n  \n  \n  //\n  // damped state changes\n  //\n  /** Applies a change to the current zoom.  */\n  zoom(dz){\n    var cam = this.cam;\n    var distance_tmp = cam.state.distance + dz;\n    \n    // check lower bound\n    if(distance_tmp < cam.distance_min) {\n      distance_tmp = cam.distance_min;\n      cam.dampedZoom.stop();\n    }\n    \n    // check upper bound\n    if(distance_tmp > cam.distance_max) {\n      distance_tmp = cam.distance_max;\n      cam.dampedZoom.stop();\n    }\n    \n    cam.state.distance = distance_tmp;\n  }\n  \n  /** Applies a change to the current pan-xValue.  */\n  panX(dx) {\n    var state = this.cam.state;\n    if(dx) {\n      var val = Rotation.applyToVec3(state.rotation, [dx, 0, 0]);\n      Vec3.add(state.center, val, state.center);\n    }\n  }\n  \n  /** Applies a change to the current pan-yValue.  */\n  panY(dy) {\n    var state = this.cam.state;\n    if(dy) {\n      var val = Rotation.applyToVec3(state.rotation, [0, dy, 0]);\n      Vec3.add(state.center, val, state.center);\n    }\n  }\n  \n  /** Applies a change to the current pan-value.  */\n  pan(dx, dy) {\n    this.cam.panX(dx);\n    this.cam.panY(dx);\n  }\n  \n  /** Applies a change to the current xRotation.  */\n  rotateX(rx) {\n   this.cam.rotate([1,0,0], rx);\n  }\n  \n  /** Applies a change to the current yRotation.  */\n  rotateY(ry) {\n    this.cam.rotate([0,1,0], ry);\n  }\n  \n  /** Applies a change to the current zRotation.  */\n  rotateZ(rz) {\n    this.cam.rotate([0,0,1], rz);\n  }\n  \n  /** Applies a change to the current rotation, using the given axis/angle.  */\n  rotate(axis, angle) {\n    var state = this.cam.state;\n    if(angle) {\n      var new_rotation = Rotation.create({axis:axis, angle:angle});\n      Rotation.applyToRotation(state.rotation, new_rotation, state.rotation);\n    }\n  }\n  \n  \n  \n\n  // \n  // interpolated states\n  //\n  /** Sets the new camera-distance, interpolated (t) between given A and B. */\n  setInterpolatedDistance(valA, valB, t) {\n    this.cam.state.distance = Scalar.mix(valA, valB, Scalar.smoothstep(t));\n  }\n  /** Sets the new camera-center, interpolated (t) between given A and B. */\n  setInterpolatedCenter(valA, valB, t) {\n    this.cam.state.center = Vec3.mix(valA, valB, Scalar.smoothstep(t));\n  }\n  /** Sets the new camera-rotation, interpolated (t) between given A and B. */\n  setInterpolatedRotation(valA, valB, t) {\n    this.cam.state.rotation = Rotation.slerp(valA, valB, t);\n  }\n  \n  \n  \n  //\n  // DISTANCE\n  //\n  /** Sets the minimum camera distance. */\n  setDistanceMin(distance_min) {\n    this.distance_min = Math.max(distance_min, this.distance_min_limit);\n    this.zoom(0); // update, to ensure new minimum\n  }\n  \n  /** Sets the maximum camera distance. */\n  setDistanceMax(distance_max) {\n    this.distance_max = distance_max;\n    this.zoom(0); // update, to ensure new maximum\n  }\n  \n  /** \n   * Sets the new camera distance.\n   *\n   * @param {double} new distance.\n   * @param {long} animation time in millis.\n   */\n  setDistance(distance, duration) {\n    this.timedzoom.start(this.state.distance, distance, duration, [this.dampedZoom]);\n  }\n  \n  /** @returns {double} the current camera distance. */\n  getDistance() {\n    return this.state.distance;\n  }\n  \n  \n  \n  //\n  // CENTER / LOOK AT\n  //\n  /** \n   * Sets the new camera center.\n   *\n   * @param {double[]} new center.\n   * @param {long} animation time in millis.\n   */\n  setCenter(center, duration) {\n    this.timedPan.start(this.state.center, center, duration, [this.dampedPanX, this.dampedPanY]);\n  }\n  \n  /** @returns {double[]} the current camera center. */\n  getCenter() {\n    return this.state.center;\n  }\n  \n  \n  \n  //\n  // ROTATION\n  //\n  /** \n   * Sets the new camera rotation (quaternion).\n   *\n   * @param {double[]} new rotation as quat[q0,q1,q2,q3].\n   * @param {long} animation time in millis.\n   */\n  setRotation(rotation, duration) {\n    this.timedRot.start(this.state.rotation, rotation, duration, [this.dampedRotX, this.dampedRotY, this.dampedRotZ]);\n  }\n  \n  /** @returns {double[]} the current camera rotation as quat[q0,q1,q2,q3]. */\n  getRotation() {\n    return this.state.rotation;\n  }\n  \n\n\n  //\n  // CAMERA POSITION/EYE\n  //\n  /** @returns {double[]} the current camera position, aka. the eye position. */\n  getPosition(dst) {\n\n    var cam = this.cam;\n    var state = cam.state;\n    \n    dst = Vec3.assert(dst);\n    Rotation.applyToVec3(state.rotation, cam.LOOK, dst);\n    Vec3.mult(dst, state.distance, dst);\n    Vec3.add(dst, state.center, dst);\n\n    return dst;\n  }\n\n  //\n  // CAMERA UP\n  //\n  /** @returns {double[]} the current camera up vector. */\n  getUpVector(dst) {\n    var cam = this.cam;\n    var state = cam.state;\n    dst = Vec3.assert(dst);\n    Rotation.applyToVec3(state.rotation, cam.UP, dst);\n    return dst;\n  }\n  \n  \n  \n  \n  \n\n  //\n  // STATE (rotation, center, distance)\n  //\n  /** @returns {Object} a copy of the camera state {distance,center,rotation} */\n  getState() {\n    return this.state.copy();\n  }  \n  /** \n   * @param {Object} a new camera state {distance,center,rotation}.\n   * @param {long} animation time in millis.\n   */\n  setState(other, duration) {\n    if(other){\n      this.setDistance(other.distance, duration);\n      this.setCenter  (other.center  , duration);\n      this.setRotation(other.rotation, duration);\n    }\n  }\n\n  pushState(){\n    return (this.state_pushed = this.getState());\n  }\n  popState(duration){\n    this.setState(this.state_pushed, duration);\n  }\n  \n  /** sets the current state as reset-state. */\n  pushResetState(){\n    return (this.state_reset = this.getState());\n  }\n  /** resets the camera, by applying the reset-state. */\n  reset(duration){\n    this.setState(this.state_reset, duration);\n  }\n  \n  \n  \n  \n  \n\n  \n  \n  /** sets the rotation scale/speed. */\n  setRotationScale(scale_rotation){\n    this.scale_rotation = scale_rotation;\n  }\n  /** sets the pan scale/speed. */\n  setPanScale(scale_pan){\n    this.scale_pan = scale_pan;\n  }\n  /** sets the zoom scale/speed. */\n  setZoomScale(scale_zoom){\n    this.scale_zoom = scale_zoom;\n  }\n  /** sets the wheel scale/speed. */\n  setWheelScale(wheelScale) {\n    this.scale_zoomwheel = wheelScale;\n  }\n  /** @returns the rotation scale/speed. */\n  getRotationScale(){\n    return this.scale_rotation;\n  }\n  /** @returns the pan scale/speed. */\n  getPanScale() {\n    return this.scale_pan;\n  }\n  /** @returns the zoom scale/speed. */\n  getZoomScale() {\n    return this.scale_zoom;\n  }\n  /** @returns the wheel scale/speed. */\n  getWheelScale() {\n    return this.scale_zoomwheel;\n  }\n  \n  /** sets the default damping scale/speed. */\n  setDamping(damping) {\n    this.dampedZoom.damping = damping;\n    this.dampedPanX.damping = damping;\n    this.dampedPanY.damping = damping;\n    this.dampedRotX.damping = damping;\n    this.dampedRotY.damping = damping;\n    this.dampedRotZ.damping = damping;\n  }\n  /** sets the default interpolation time in millis. */\n  setDefaultInterpolationTime(duration) {\n    this.timedRot .default_duration = duration;\n    this.timedPan .default_duration = duration;\n    this.timedzoom.default_duration = duration;\n  }\n  \n  \n  /** \n   * sets the rotation constraint for each axis separately.\n   *\n   * @param {boolean} yaw constraint\n   * @param {boolean} pitch constraint\n   * @param {boolean} roll constraint\n   */\n  setRotationConstraint(yaw, pitch, roll) {\n    var cam = this.cam;\n    cam.FIXED_CONSTRAINT  = 0;\n    cam.FIXED_CONSTRAINT |= yaw   ? cam.AXIS.YAW   : 0;\n    cam.FIXED_CONSTRAINT |= pitch ? cam.AXIS.PITCH : 0;\n    cam.FIXED_CONSTRAINT |= roll  ? cam.AXIS.ROLL  : 0;\n  }\n  \n\n \n  /**\n   * \n   * begin screen-aligned 2D-drawing.\n   * \n   * <pre>\n   * beginHUD()\n   *   disabled depth test\n   *   ortho\n   *   ... your code is executed here ...\n   * endHUD()\n   * </pre>\n   * \n   */\n  beginHUD(renderer, w, h) {\n    var cam = this.cam;\n    renderer = renderer || cam.renderer;\n    \n    if(!renderer) return;\n    this.pushed_rendererState = renderer.push();\n    \n    var gl = renderer.drawingContext;\n    var w = (w !== undefined) ? w : renderer.width;\n    var h = (h !== undefined) ? h : renderer.height;\n    var d = Number.MAX_VALUE;\n    \n    gl.flush();\n    // gl.finish();\n    \n    // 1) disable DEPTH_TEST\n    gl.disable(gl.DEPTH_TEST);\n    // 2) push modelview/projection\n    //    p5 is not creating a push/pop stack\n    this.pushed_uMVMatrix = renderer.uMVMatrix.copy();\n    this.pushed_uPMatrix  = renderer.uPMatrix .copy();\n    \n    // 3) set new modelview (identity)\n    renderer.resetMatrix();\n    // 4) set new projection (ortho)\n    renderer._curCamera.ortho(0, w, -h, 0, -d, +d);\n    // renderer.ortho();\n    // renderer.translate(-w/2, -h/2);\n\n  }\n  \n  \n\n  /**\n   * \n   * end screen-aligned 2D-drawing.\n   * \n   */\n  endHUD(renderer) {\n    var cam = this.cam;\n    renderer = renderer || cam.renderer;\n    \n    if(!renderer) return;\n    \n    var gl = renderer.drawingContext;\n    \n    gl.flush();\n    // gl.finish();\n      \n    // 2) restore modelview/projection\n    renderer.uMVMatrix.set(this.pushed_uMVMatrix);\n    renderer.uPMatrix .set(this.pushed_uPMatrix );\n    // 1) enable DEPTH_TEST\n    gl.enable(gl.DEPTH_TEST);\n    renderer.pop(this.pushed_rendererState);\n  }\n\n  \n  \n}\n\n\n\n\n\n\n\n\n/**\n * Damped callback, that accepts the resulting damped/smooth value.\n *\n * @callback dampedCallback\n * @param {double} value - the damped/smoothed value\n *\n */\n\n \n/**\n *\n * DampedAction, for smoothly changing a value to zero.\n *\n * @param {dampedCallback} cb - callback that accepts the damped value as argument.\n */\nclass DampedAction {\n  \n  \n  /**  @constructor */\n  constructor(cb){\n    this.value = 0.0;\n    this.damping = 0.85;\n    this.action = cb;\n  }\n\n  /** adds a value to the current value beeing damped. \n   * @param {double} force - the value beeing added.\n   */\n  addForce(force) {\n    this.value += force;\n  }\n\n  /** updates the damping and calls {@link damped-callback}. */\n  update() {\n    var active = (this.value*this.value) > 0.000001;\n    if (active){\n      this.action(this.value);\n      this.value *= this.damping;\n    } else {\n      this.stop();\n    }\n    return active;\n  }\n  \n  /** stops the damping. */\n  stop() {\n    this.value = 0.0;\n  }\n\n}\n\n\n\n\n/**\n * Interpolation callback, that implements any form of interpolation between\n * two values A and B and the interpolationparameter t.\n * <pre>\n *   linear: A * (1-t) + B * t\n *   smooth, etc...\n * </pre>\n * @callback interpolationCallback\n * @param {Object} A - First Value\n * @param {Object} B - Second Value\n * @param {double} t - interpolation parameter [0, 1]\n *\n */\n\n\n/**\n *\n * Interpolation, for smoothly changing a value by interpolating it over time.\n *\n * @param {interpolationCallback} cb - callback for interpolating between two values.\n */\nclass Interpolation {\n  \n  /**  @constructor */\n  constructor(cb){\n    this.default_duration = 300;\n    this.action = cb;\n  }\n  \n  /** starts the interpolation.\n   *  If the given interpolation-duration is 0, then\n   * {@link interpolation-callback} is called immediately.\n   */\n  start(valA, valB, duration, actions) {\n    for(var x in actions){\n      actions[x].stop();\n    }\n    this.valA = valA;\n    this.valB = valB;\n    this.duration = (duration === undefined) ? this.default_duration : duration;\n    this.timer = new Date().getTime();\n    this.active = this.duration > 0;\n    if(!this.active){\n      this.interpolate(1);\n    }\n  }\n  \n  /** updates the interpolation and calls {@link interpolation-callback}.*/\n  update() {\n    if(this.active){\n      var t = (new Date().getTime() - this.timer) / this.duration;\n      if (t > 0.995) {\n        this.interpolate(1);\n        this.stop();\n      } else {\n        this.interpolate(t);\n      }\n    }\n  }\n  \n  interpolate(t){\n    this.action(this.valA, this.valB, t);\n  }\n  \n  /** stops the interpolation. */\n  stop() {\n    this.active = false;\n  }\n\n}\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// ROTATION (Quaternion)\n//\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Rotation as Quaternion [q0, q1, q2, q3]\n *\n * Note: Only functions that were required for the EasyCam to work are implemented.\n * \n * @namespace\n */\nvar Rotation = \n{\n  \n  assert : function(dst){\n    return ((dst === undefined) || (dst.constructor !== Array)) ? [1, 0, 0, 0] : dst;\n  },\n  \n  /** @returns {Number[]} an identity rotation [1,0,0,0] */\n  identity : function() {\n    return [1, 0, 0, 0];\n  },\n  \n  /** \n   * Applies the rotation to a vector and returns dst or a new vector.\n   *\n   * @param {Number[]} rot - Rotation (Quaternion)\n   * @param {Number[]} vec - vector to be rotated by rot\n   * @param {Number[]} dst - resulting vector\n   * @returns {Number[]} dst- resulting vector\n   */\n  applyToVec3 : function(rot, vec, dst) {\n    \n    var [x,y,z] = vec;\n    var [q0,q1,q2,q3] = rot;\n    \n    var s = q1 * x + q2 * y + q3 * z;\n    \n    dst = Vec3.assert(dst);\n    dst[0] = 2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x; \n    dst[1] = 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y; \n    dst[2] = 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z;\n    return dst;\n  },\n  \n  /** \n   * Applies the rotation to another rotation and returns dst or a new rotation.\n   *\n   * @param {Number[]} rotA - RotationA (Quaternion)\n   * @param {Number[]} rotB - RotationB (Quaternion)\n   * @param {Number[]} dst - resulting rotation\n   * @returns {Number[]} dst - resulting rotation\n   */\n  applyToRotation(rotA, rotB, dst) {\n    var [a0,a1,a2,a3] = rotA;\n    var [b0,b1,b2,b3] = rotB;\n    \n    dst = Rotation.assert(dst);\n    dst[0] = b0 * a0 - (b1 * a1 +  b2 * a2 + b3 * a3);\n    dst[1] = b1 * a0 +  b0 * a1 + (b2 * a3 - b3 * a2);\n    dst[2] = b2 * a0 +  b0 * a2 + (b3 * a1 - b1 * a3);\n    dst[3] = b3 * a0 +  b0 * a3 + (b1 * a2 - b2 * a1);\n    return dst;     \n  },\n  \n  \n  /** \n   * Interpolates a rotation.\n   *\n   * @param {Number[]} rotA - RotationA (Quaternion)\n   * @param {Number[]} rotB - RotationB (Quaternion)\n   * @param {Number  } t - interpolation parameter\n   * @param {Number[]} dst - resulting rotation\n   * @returns {Number[]} dst - resulting rotation\n   */\n  slerp : function(rotA, rotB, t, dst) {\n    var [a0,a1,a2,a3] = rotA;\n    var [b0,b1,b2,b3] = rotB;\n    \n    var cosTheta = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    if (cosTheta < 0) {\n      b0 = -b0;\n      b1 = -b1;\n      b2 = -b2;\n      b3 = -b3;\n      cosTheta = -cosTheta;\n    }\n    \n    var theta = Math.acos(cosTheta);\n    var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    \n    var w1, w2;\n    if (sinTheta > 0.001) {\n      w1 = Math.sin((1.0 - t) * theta) / sinTheta;\n      w2 = Math.sin(t * theta) / sinTheta;\n    } else {\n      w1 = 1.0 - t;\n      w2 = t;\n    }\n    \n    dst = Rotation.assert(dst);\n    dst[0] = w1 * a0 + w2 * b0; \n    dst[1] = w1 * a1 + w2 * b1; \n    dst[2] = w1 * a2 + w2 * b2; \n    dst[3] = w1 * a3 + w2 * b3;\n    \n    return Rotation.create({rotation : dst, normalize : true}, dst);\n  },\n  \n  /** \n   * Creates/Initiates a new Rotation\n   *\n   * <pre>\n   *\n   *    1) Axis,Angle:\n   *       {\n   *         axis : [x, y, z],\n   *         angle: double\n   *       }\n   *      \n   *    2) Another Rotation:\n   *       {\n   *         rotation : [q0, q1, q2, q3],\n   *         normalize: boolean\n   *       }\n   *      \n   *    3) 3 euler angles, XYZ-order:\n   *       {\n   *         angles_xyz : [rX, rY, rZ]\n   *       }\n   *   \n   * </pre>\n   *\n   *\n   * @param {Object} def - Definition, for creating the new Rotation\n   * @param {Number[]} dst - resulting rotation\n   * @returns {Number[]} dst - resulting rotation\n   */\n  create : function(def, dst) {\n    \n    dst = Rotation.assert(dst);\n    \n    // 1) from axis and angle\n    if(def.axis)\n    {\n      var axis = def.axis;\n      var angle = def.angle;\n    \n      var norm = Vec3.mag(axis);\n      if (norm == 0.0) return; // vector is of zero length\n      \n      var halfAngle = -0.5 * angle;\n      var coeff = Math.sin(halfAngle) / norm;\n\n      dst[0] = Math.cos(halfAngle);\n      dst[1] = coeff * axis[0];\n      dst[2] = coeff * axis[1];\n      dst[3] = coeff * axis[2];\n      return dst;\n    }\n    \n    // 2) from another rotation\n    if(def.rotation)\n    {\n      dst[0] = def.rotation[0];\n      dst[1] = def.rotation[1];\n      dst[2] = def.rotation[2];\n      dst[3] = def.rotation[3];\n      \n      if(def.normalize){\n        var inv = 1.0 / Math.sqrt(dst[0]*dst[0] + dst[1]*dst[1] + dst[2]*dst[2] + dst[3]*dst[3]);\n        dst[0] *= inv;\n        dst[1] *= inv;\n        dst[2] *= inv;\n        dst[3] *= inv;\n      }\n       \n      return dst;\n    }\n    \n    // 3) from 3 euler angles, order XYZ\n    if(def.angles_xyz){\n      \n      var ax = -0.5 *  def.angles_xyz[0];\n      var ay = -0.5 *  def.angles_xyz[1];\n      var az = -0.5 *  def.angles_xyz[2];\n      \n      var rotX = [Math.cos(ax), Math.sin(ax), 0, 0];\n      var rotY = [Math.cos(ay), 0, Math.sin(ay), 0];\n      var rotZ = [Math.cos(az), 0, 0, Math.sin(az)];\n      \n      Rotation.applyToRotation(rotY, rotZ, dst);\n      Rotation.applyToRotation(rotX, dst, dst);\n \n      return dst;\n    }\n\n\n  }\n  \n  \n  //\n  // ... to be continued ...\n  //\n  \n};\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// SCALAR\n//\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Scalar as a simple number.\n *\n * Note: Only functions that were required for the EasyCam to work are implemented.\n *\n * @namespace\n */\nvar Scalar = {\n  \n  /**\n   * Linear interpolation between A and B using t[0,1]\n   */\n  mix : function(a, b, t){\n    return a * (1-t) + b * t;\n  },\n     \n  /**\n   * modifying t as a function of smoothstep(0,1,t);\n   */\n  smoothstep : function(x) {\n    return x * x * (3 - 2 * x);\n  },\n  \n  /**\n   * modifying t as a function of smootherstep(0,1,t);\n   */\n  smootherstep : function(x) {\n    return x * x * x * (x * (x * 6 - 15) + 10);\n  },\n  \n};\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// VEC3\n//\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Vec3 as a 3D vector (Array)\n *\n * @namespace\n */\nvar Vec3 = \n{\n  \n  assert : function(dst){\n    return ((dst === undefined) || (dst.constructor !== Array)) ? [0, 0, 0] : dst;\n  },\n  \n  isScalar : function(arg){\n    // TODO: do some profiling to figure out what fails\n    return (arg !== undefined) && (arg.constructor !== Array);\n    // return typeof(arg) === 'number';\n  },\n  \n  /** addition: <pre> dst = a + b </pre>  */\n  add : function(a, b, dst) {\n    dst = this.assert(dst);\n    if(this.isScalar(b)){\n      dst[0] = a[0] + b;\n      dst[1] = a[1] + b;\n      dst[2] = a[2] + b;\n    } else {\n      dst[0] = a[0] + b[0];\n      dst[1] = a[1] + b[1];\n      dst[2] = a[2] + b[2];\n    }\n    return dst;\n  },\n\n  /** componentwise multiplication: <pre> dst = a * b </pre>  */\n  mult : function(a, b, dst){\n    dst = this.assert(dst);\n    if(this.isScalar(b)){\n      dst[0] = a[0] * b;\n      dst[1] = a[1] * b;\n      dst[2] = a[2] * b;\n    } else {\n      dst[0] = a[0] * b[0];\n      dst[1] = a[1] * b[1];\n      dst[2] = a[2] * b[2];\n    }\n    return dst;\n  },\n\n  /** squared length  */\n  magSq : function(a) {\n    return a[0]*a[0] + a[1]*a[1] + a[2]*a[2];\n  },\n  \n  /** length  */\n  mag : function(a) {\n    return Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);\n  },\n  \n  /** dot-product  */\n  dot : function(a, b) {\n    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];\n  },\n  \n  /** cross-product  */\n  cross : function(a, b, dst) {\n    dst = this.assert(dst);\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = a[2] * b[0] - a[0] * b[2];\n    dst[2] = a[0] * b[1] - a[1] * b[0];\n    return dst;\n  },\n\n  /** angle  */\n  angle : function(v1, v2){\n\n    var normProduct = this.mag(v1) * this.mag(v2);\n    if (normProduct === 0.0) {\n      return 0.0; // at least one vector is of zero length\n    }\n    \n    var dot = this.dot(v1, v2);\n    var threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n      // the vectors are almost aligned, compute using the sine\n      var v3 = this.cross(v1, v2);\n      if (dot >= 0) {\n        return Math.asin(this.mag(v3) / normProduct);\n      } else {\n        return Math.PI - Math.asin(this.mag(v3) / normProduct);\n      }\n    }\n    \n    // the vectors are sufficiently separated to use the cosine\n    return Math.acos(dot / normProduct);\n  },\n  \n  /** linear interpolation: <pre> dst = a * (1 - t) + b * t </pre> */\n  mix(a, b, t, dst) {\n    dst = this.assert(dst);\n    dst[0] = Scalar.mix(a[0], b[0], t); \n    dst[1] = Scalar.mix(a[1], b[1], t);\n    dst[2] = Scalar.mix(a[2], b[2], t);\n    return dst;\n  },\n  \n  \n  //\n  // ... to be continued ...\n  //\n  \n};\n\n\n\n\n\n\n\n\n  \n////////////////////////////////////////////////////////////////////////////////\n//\n// public objects\n//\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @static\n */\nEasyCam.INFO = INFO; // make static\nObject.freeze(INFO); // and constant\n\n\next = (ext !== undefined) ? ext : {};\n\n/**\n * @memberof Dw\n */\next.EasyCam = EasyCam;\n/**\n * @memberof Dw\n */\next.DampedAction = DampedAction;\n/**\n * @memberof Dw\n */\next.Interpolation = Interpolation;\n/**\n * @memberof Dw\n */\next.Rotation = Rotation;\n/**\n * @memberof Dw\n */\next.Vec3 = Vec3;\n/**\n * @memberof Dw\n */\next.Scalar = Scalar;\n\nreturn ext;\n  \n\n})(Dw);\n\n\n\n/**\n * @submodule Camera\n * @for p5\n */\n\nif(p5){\n  \n    \n  /**\n   * p5.EasyCam creator function. \n   * Arguments are optional, and equal to the default EasyCam constructor.\n   * @return {EasyCam} a new EasyCam\n   */\n  p5.prototype.createEasyCam = function(/* p5.RendererGL, {state} */){\n    \n    var renderer = this._renderer;\n    var args     = arguments[0];\n    \n    if(arguments[0] instanceof p5.RendererGL){\n      renderer = arguments[0];\n      args     = arguments[1]; // could still be undefined, which is fine\n    } \n    \n    return new Dw.EasyCam(renderer, args); \n  }\n}",["66","67"],"/Users/bvk/Documents/Active/tend/lsystem-examples/src/LSCustomizer.tsx",["68","69"],"\nimport LSystem, { Axiom, parseAxiom, parseProduction, Production } from \"@bvk/lsystem\";\nimport { axiomToStr } from \"@bvk/lsystem/dist/parser\";\nimport React from \"react\"\nimport { updateParenthesizedType } from \"typescript\";\n\ninterface CustomizerProps {\n  onLSReset(LS: LSystem): void;\n  onLSIterated(LS: LSystem): void;\n  initProductions?: string[],\n  initAxiom?: string,\n  initIterations?: number\n}\n\ninterface CustomizerState {\n  iterations: number,\n  errorMessage: string,\n}\n\n/**\n * LSCustomizer stores the LSystem that is updated by the UI.\n * When the LSCustomizer updates the LSystem, or the iterations, it uses callback functions to update its parent\n */\nexport default class LSCustomizer extends React.Component<CustomizerProps, CustomizerState> {\n  LSystem: LSystem | undefined;\n  axiom: Axiom | undefined;\n  productions: Production[] | undefined;\n\n  state: CustomizerState = {\n    iterations: this.props.initIterations || 1,\n    errorMessage: \"\"\n  }\n  //Receive state from children, and update LSystem\n  updateAxiom = (ax: Axiom) => {\n    this.axiom = ax;\n    this.resetLS();\n  }\n  updateProductions = (productions: Production[]) => {\n    this.productions = productions;\n    this.resetLS();\n  }\n  resetLS = () => {\n    if (this.axiom && this.productions && this.productions.length > 0) {\n      try {\n        let newLS = new LSystem(this.axiom, this.productions);\n        //TODO: ASYNC AWAIT\n        newLS.iterate();\n        this.setState({ errorMessage: \"\" });\n        this.props.onLSReset(newLS);\n        this.LSystem = newLS;\n      } catch (e) {\n        this.setState({ errorMessage: e.message });\n      }\n    } else {\n      this.setState({ errorMessage: \"Not recreating LSystem, axiom or productions didn't exist\" })\n    }\n  }\n  updateIterations = (e: React.ChangeEvent<HTMLInputElement>) => {\n    let newValue = parseFloat(e.target.value);\n    this.setState({ iterations: newValue });\n    if (!this.LSystem) {\n      this.setState({ errorMessage: \"cant iterate an LSystem doesnt exist yet\" });\n      return;\n    }\n    //TODO: ASYNC/AWAIT\n    this.LSystem.setIterations(newValue);\n    this.LSystem.iterate();\n    this.props.onLSIterated(this.LSystem);\n  }\n\n  //Generate UI\n  getControls = () => {\n    let controls = [];\n    let axiomControl = <AxiomCustomizer didUpdate={this.updateAxiom} key={\"axiom-controls\"} initAxiom={this.props.initAxiom} />\n    controls.push(axiomControl);\n    let productionsControl = <ManyProductionCustomizer didUpdate={this.updateProductions} key={\"production-controls\"} initProductions={this.props.initProductions} />\n    controls.push(productionsControl);\n    let iterationControl = this.getIterationController();\n    controls.push(iterationControl);\n    return <div style={{ display: \"flex\", flexDirection: \"column\", gap: \"12px\" }}> {controls} </div>;\n  }\n  getIterationController = () => {\n    return (\n      <div key=\"iterations\">\n        <label> Iterations </label>\n        <input type=\"range\" min={1} max={20} onChange={this.updateIterations} value={this.state.iterations} />\n      </div>\n    )\n  }\n  render = () => {\n    return (\n      <div>\n        <div> LSystem </div>\n        <div className=\"subtext\">{this.state.errorMessage}</div>\n        <div> {this.getControls()} </div>\n      </div>)\n  }\n}\n\n\n/**\n * AxiomCustomizer controls updating of the Axiom\n*/\ninterface AxiomProps {\n  initAxiom?: string;\n  didUpdate(ax: Axiom): void;\n}\ninterface AxiomState {\n  axiomString: string;\n  errorMessage: string;\n  axiomParses: boolean;\n}\nexport class AxiomCustomizer extends React.Component<AxiomProps, AxiomState> {\n  state: AxiomState = {\n    axiomString: this.props.initAxiom || \"\",\n    axiomParses: false,\n    errorMessage: \"\"\n  }\n  componentDidMount = () => {\n    this.parseAxiom(this.state.axiomString);\n  }\n  parseAxiom = (axiomString: string) => {\n    this.setState({ axiomString: axiomString });\n    try {\n      let axiomObj = parseAxiom(axiomString);\n      this.setState({ axiomParses: true, errorMessage: \"\" });\n      this.props.didUpdate(axiomObj);\n    } catch (e) {\n      this.setState({ axiomParses: false, errorMessage: e.message });\n    }\n  }\n  render() {\n    return (\n      <div>\n        <label> Axiom </label>\n        <input className={`padded border-bottom ${this.state.axiomParses ? 'green-border' : 'red-border'}`}\n          onChange={(e) => this.parseAxiom(e.target.value)}\n          value={this.state.axiomString} />\n        <div className=\"red subtext\"> {this.state.errorMessage} </div>\n      </div>)\n  }\n}\n\n/**\n * ManyProductionCustomizer controls updating of the Axiom\n*/\ninterface ManyProductionProps {\n  initProductions?: string[],\n  didUpdate(productions: Production[]): void\n}\ninterface ManyProductionState {\n  productionStrDict: { [key: string]: string },\n  errorMessages: { [key: string]: string }\n}\nexport class ManyProductionCustomizer extends React.Component<ManyProductionProps, ManyProductionState> {\n  productionObjDict: { [key: string]: Production } = {};\n  constructor(props: ManyProductionProps) {\n    super(props);\n    let productionDict: { [key: string]: string } = {};\n    if (this.props.initProductions) {\n      this.props.initProductions.forEach((initProduction, index) => {\n        let pKey = index + \"-production\" as string;\n        productionDict[pKey] = initProduction;\n      })\n    }\n    this.state = {\n      productionStrDict: productionDict,\n      errorMessages: {}\n    }\n  }\n  //Updating and syncing state\n  componentDidMount = () => {\n    if (this.props.initProductions) {\n      let productionKeys = Object.keys(this.state.productionStrDict);\n      productionKeys.forEach((pKey) => {\n        let pString = this.state.productionStrDict[pKey];\n        this.updateProduction(pString, pKey);\n      })\n    }\n  }\n  updateParent = () => {\n    let productions = { ...this.productionObjDict };\n    let productionValues = Object.values(productions);\n    //TODO: Copying them over here, but this should happen in LSystem instead. Remove later\n    let copiedvalues: Production[] = [];\n    productionValues.forEach((pv) => {\n      let npv = { ...pv };\n      copiedvalues.push(npv);\n    })\n    console.log(\"ProductionCuztomizer sending back to parent\");\n    console.log(productions);\n    this.props.didUpdate(copiedvalues);\n  }\n  updateProduction = (productionString: string, productionKey: string) => {\n    console.log(\"Updating: \" + productionString + \" with key \" + productionKey);\n    let productionStrings = this.state.productionStrDict;\n    productionStrings[productionKey] = productionString;\n    this.setState({ productionStrDict: productionStrings });\n    try {\n      let productionObj = parseProduction(productionString);\n      this.productionObjDict[productionKey] = productionObj;\n      console.log(this.productionObjDict);\n      this.updateParent();\n      let errorMessages = this.state.errorMessages;\n      delete errorMessages[productionKey];\n      this.setState({ errorMessages: errorMessages });\n    } catch (e) {\n      let errorMessages = this.state.errorMessages;\n      errorMessages[productionKey] = e.message;\n      this.setState({ errorMessages: errorMessages });\n    }\n  }\n  //Altering number of productions\n  removeProduction = (productionKey: string) => {\n    let productionStrings = this.state.productionStrDict;\n    delete productionStrings[productionKey];\n    let errorStrings = this.state.errorMessages;\n    delete errorStrings[productionKey];\n    this.setState({ productionStrDict: productionStrings, errorMessages: errorStrings });\n    delete this.productionObjDict[productionKey];\n    this.updateParent();\n  }\n  addProduction = () => {\n    let numKeys = Object.keys(this.state.productionStrDict).length;\n    let nextKey = numKeys + 1 + \"-production\";\n    let productionStrings = this.state.productionStrDict;\n    productionStrings[nextKey] = \"\";\n    this.setState({ productionStrDict: productionStrings });\n  }\n  //Generating UI \n  getProductions = () => {\n    let productionKeys = Object.keys(this.state.productionStrDict);\n    return productionKeys.map((pKey, index) => {\n      let pString = this.state.productionStrDict[pKey];\n      let productionInput = (\n        <div key={pKey} >\n          <label> Production {index} </label>\n          <input key={pKey + \"-input\"}\n            className={`padded border-bottom ${this.state.errorMessages[pKey] ? 'red-border' : 'green-border'}`}\n            onChange={(e) => this.updateProduction(e.target.value, pKey)}\n            value={pString} />\n          <div className=\"clickable right-button\"\n            onClick={(e) => this.removeProduction(pKey)}> (-) </div>\n          <div className=\"red subtext\"> {this.state.errorMessages[pKey]} </div>\n        </div>);\n      return productionInput;\n    })\n  }\n  render() {\n    return (<div>\n      {this.getProductions()}\n      <div className=\"clickable\" onClick={this.addProduction}>Add production</div>\n    </div>)\n  }\n}",{"ruleId":"70","severity":1,"message":"71","line":3,"column":8,"nodeType":"72","messageId":"73","endLine":3,"endColumn":14},{"ruleId":"70","severity":1,"message":"74","line":5,"column":8,"nodeType":"72","messageId":"73","endLine":5,"endColumn":22},{"ruleId":"70","severity":1,"message":"75","line":7,"column":8,"nodeType":"72","messageId":"73","endLine":7,"endColumn":20},{"ruleId":"76","replacedBy":"77"},{"ruleId":"78","replacedBy":"79"},{"ruleId":"70","severity":1,"message":"80","line":3,"column":17,"nodeType":"72","messageId":"73","endLine":3,"endColumn":23},{"ruleId":"70","severity":1,"message":"81","line":4,"column":10,"nodeType":"72","messageId":"73","endLine":4,"endColumn":12},{"ruleId":"70","severity":1,"message":"82","line":5,"column":10,"nodeType":"72","messageId":"73","endLine":5,"endColumn":17},{"ruleId":"70","severity":1,"message":"83","line":35,"column":11,"nodeType":"72","messageId":"73","endLine":35,"endColumn":14},{"ruleId":"84","severity":1,"message":"85","line":67,"column":59,"nodeType":"86","messageId":"87","endLine":67,"endColumn":61},{"ruleId":"70","severity":1,"message":"88","line":2,"column":8,"nodeType":"72","messageId":"73","endLine":2,"endColumn":15},{"ruleId":"70","severity":1,"message":"89","line":2,"column":26,"nodeType":"72","messageId":"73","endLine":2,"endColumn":36},{"ruleId":"70","severity":1,"message":"90","line":2,"column":38,"nodeType":"72","messageId":"73","endLine":2,"endColumn":48},{"ruleId":"84","severity":1,"message":"91","line":34,"column":94,"nodeType":"86","messageId":"87","endLine":34,"endColumn":96},{"ruleId":"92","severity":1,"message":"93","line":21,"column":1,"nodeType":"94","messageId":"95","endLine":21,"endColumn":14,"fix":"96"},{"ruleId":"97","severity":1,"message":"98","line":103,"column":17,"nodeType":"99","messageId":"100","endLine":108,"endColumn":6,"fix":"101"},{"ruleId":"102","severity":1,"message":"103","line":172,"column":25,"nodeType":"104","messageId":"105","endLine":172,"endColumn":49,"fix":"106"},{"ruleId":"102","severity":1,"message":"103","line":173,"column":25,"nodeType":"104","messageId":"105","endLine":173,"endColumn":49,"fix":"107"},{"ruleId":"102","severity":1,"message":"103","line":174,"column":25,"nodeType":"104","messageId":"105","endLine":174,"endColumn":49,"fix":"108"},{"ruleId":"109","severity":1,"message":"110","line":243,"column":13,"nodeType":"72","messageId":"73","endLine":243,"endColumn":15},{"ruleId":"84","severity":1,"message":"85","line":382,"column":33,"nodeType":"86","messageId":"87","endLine":382,"endColumn":35},{"ruleId":"102","severity":1,"message":"103","line":440,"column":40,"nodeType":"104","messageId":"105","endLine":440,"endColumn":72,"fix":"111"},{"ruleId":"102","severity":1,"message":"112","line":579,"column":7,"nodeType":"104","messageId":"105","endLine":579,"endColumn":25,"fix":"113"},{"ruleId":"102","severity":1,"message":"112","line":580,"column":7,"nodeType":"104","messageId":"105","endLine":580,"endColumn":25,"fix":"114"},{"ruleId":"102","severity":1,"message":"115","line":583,"column":7,"nodeType":"104","messageId":"105","endLine":583,"endColumn":27,"fix":"116"},{"ruleId":"102","severity":1,"message":"115","line":584,"column":7,"nodeType":"104","messageId":"105","endLine":584,"endColumn":27,"fix":"117"},{"ruleId":"102","severity":1,"message":"118","line":985,"column":5,"nodeType":"104","messageId":"105","endLine":985,"endColumn":36,"fix":"119"},{"ruleId":"102","severity":1,"message":"118","line":986,"column":5,"nodeType":"104","messageId":"105","endLine":986,"endColumn":36,"fix":"120"},{"ruleId":"121","severity":1,"message":"122","line":1029,"column":9,"nodeType":"72","messageId":"123","endLine":1029,"endColumn":10},{"ruleId":"121","severity":1,"message":"124","line":1030,"column":9,"nodeType":"72","messageId":"123","endLine":1030,"endColumn":10},{"ruleId":"102","severity":1,"message":"125","line":1041,"column":29,"nodeType":"104","messageId":"105","endLine":1041,"endColumn":52,"fix":"126"},{"ruleId":"102","severity":1,"message":"127","line":1072,"column":5,"nodeType":"104","messageId":"105","endLine":1072,"endColumn":27,"fix":"128"},{"ruleId":"84","severity":1,"message":"85","line":1371,"column":16,"nodeType":"86","messageId":"87","endLine":1371,"endColumn":18},{"ruleId":"129","severity":1,"message":"130","line":1645,"column":4,"nodeType":"72","messageId":"131","endLine":1645,"endColumn":6},{"ruleId":"76","replacedBy":"132"},{"ruleId":"78","replacedBy":"133"},{"ruleId":"70","severity":1,"message":"134","line":3,"column":10,"nodeType":"72","messageId":"73","endLine":3,"endColumn":20},{"ruleId":"70","severity":1,"message":"135","line":5,"column":10,"nodeType":"72","messageId":"73","endLine":5,"endColumn":33},"@typescript-eslint/no-unused-vars","'P5Draw' is defined but never used.","Identifier","unusedVar","'staticExamples' is defined but never used.","'LSCustomizer' is defined but never used.","no-native-reassign",["136"],"no-negated-in-lhs",["137"],"'Letter' is defined but never used.","'Dw' is defined but never used.","'Console' is defined but never used.","'ctx' is assigned a value but never used.","eqeqeq","Expected '===' and instead saw '=='.","BinaryExpression","unexpected","'lsystem' is defined but never used.","'parseAxiom' is defined but never used.","'Production' is defined but never used.","Expected '!==' and instead saw '!='.","strict","'use strict' is unnecessary inside of modules.","ExpressionStatement","module",{"range":"138","text":"139"},"new-parens","Missing '()' invoking a constructor.","NewExpression","missing",{"range":"140","text":"141"},"no-whitespace-before-property","Unexpected whitespace before property bind.","MemberExpression","unexpectedWhitespace",{"range":"142","text":"143"},{"range":"144","text":"143"},{"range":"145","text":"143"},"no-unused-vars","'pd' is assigned a value but never used.",{"range":"146","text":"143"},"Unexpected whitespace before property stop.",{"range":"147","text":"143"},{"range":"148","text":"143"},"Unexpected whitespace before property update.",{"range":"149","text":"143"},{"range":"150","text":"143"},"Unexpected whitespace before property default_duration.",{"range":"151","text":"143"},{"range":"152","text":"143"},"no-redeclare","'w' is already defined.","redeclared","'h' is already defined.","Unexpected whitespace before property copy.",{"range":"153","text":"143"},"Unexpected whitespace before property set.",{"range":"154","text":"143"},"no-use-before-define","'Dw' was used before it was defined.","usedBeforeDefined",["136"],["137"],"'axiomToStr' is defined but never used.","'updateParenthesizedType' is defined but never used.","no-global-assign","no-unsafe-negation",[455,468],"",[2444,2444],"()",[4311,4315],".",[4367,4370],[4423,4425],[12699,12702],[16661,16663],[16689,16691],[16758,16760],[16788,16790],[27012,27014],[27060,27062],[28461,28463],[29087,29089]]